
<!DOCTYPE html>
<html>
<head>
  <title>JLisp</title>
</head>
<body>
  <script>
  var lispProgram = `(import void PrintInt (int i) "console.log(i);")

(export int Main ()
    (int x y)
    (= y 4)
    (= x (+ 5 3))
    (PrintInt x)
    (= x (+ x y))
    (return x)
)
`;
  

function CompileAndRun(main){
function LispParser(code){
    var index = 0;

    function IsDigit(c){
        return c>='0' && c<='9';
    }

    function IsWhitespace(c){
        return c==' ' || c=='\t' || c=='\n' || c=='\r';
    }

    function Parse(){
        var result = ['obj'];
        while(true){
            if(index>=code.length){
                return result;
            }
            else if(code[index] == ')'){
                index++;
                return result;
            }
            else if(code[index] == '('){
                index++;
                result.push(Parse());
            }
            else if(IsWhitespace(code[index])){
                index++;
            }
            else if(code[index] == '"'){
                index++;
                var start = index;
                while(true){
                    if(code[index] == '"'){
                        result.push(['string', code.substring(start, index)]);
                        index++;
                        break;
                    }
                    index++;
                }
            }
            else{
                var start = index;
                while(true){
                    var breakVarname = index>=code.length
                        || code[index] == '('
                        || code[index] == ')'
                        || code[index] == '"'
                        || IsWhitespace(code[index]);
                    if(breakVarname){
                        var value = code.substring(start, index);
                        if(IsDigit(value[0])){
                            result.push(['int', parseFloat(value)]);
                        }
                        else{
                            result.push(['varname', value]);
                        }
                        break;
                    }
                    index++;
                }
            }
        }
    }

    return Parse();
}

class Literal{
    constructor(literal){
        this.literal = literal;
    }

    Check(obj){
        return (obj[0] == 'varname' && obj[1] == this.literal);
    }

    Parse(obj){
        return undefined;
    }
}

class String{
    Check(obj){
        return (obj[0] == 'string');
    }

    Parse(obj){
        return obj[1];
    }
}

class Varname{
    Check(obj){
        return (obj[0] == 'varname');
    }

    Parse(obj){
        return obj[1];
    }
}

class Int{
    Check(obj){
        return (obj[0] == 'int');
    }

    Parse(obj){
        return obj[1];
    }
}

class Or{
    constructor(branches){
        this.Init(branches);
    }

    Init(branches){
        this.branches = branches;
    }

    Check(obj){
        for(var b of this.branches){
            if(b.Check(obj)){
                return true;
            }
        }
        return false;
    }

    Parse(obj){
        for(var b of this.branches){
            if(b.Check(obj)){
                var result = b.Parse(obj);
                if(typeof result != 'object'){
                    return {type:b.constructor.name, value:result};
                }
                return result;
            }
        }
        errors.push("not found branch: "+JSON.stringify(this.branches.map(o=>o.type))+" got: "+JSON.stringify(obj));
    }
}

class ArrayMultipleOf2{
    constructor(item1, item2){
        this.IsArrayMultipleOf2 = true;
        this.Init(item1, item2);
    }

    Init(item1, item2){
        this.item1 = item1;
        this.item2 = item2;
    }

    Check(obj){
        return (obj[0] == 'obj');
    }

    Parse(obj){
        if((obj.length-1)%2 == 0){
            var result = [];
            for(var i=1;i<obj.length;i+=2){
                var resultObj = {};
                resultObj[this.item1[0]] = this.item1[1].Parse(obj[i]);
                resultObj[this.item2[0]] = this.item2[1].Parse(obj[i+1]);
                result.push(resultObj);
            }
            return result;
        }
        else{
            errors.push('Expecting obj length to be multiple of 2: '+JSON.stringify(obj));
        }
    }
}

class Params{
    constructor(name, element, min, max){
        this.name = name;
        this.element = element;
        this.min = min;
        this.max = max;
    }
}

class Obj{
    constructor(type, fields, params){
        this.Init(type, fields, params);
    }

    Init(type, fields, params){
        this.type = type;
        this.fields = fields;
        this.params = params;
    }

    CheckLength(obj){
        if(this.params){
            var minValid = this.params.min==undefined || (obj.length >= this.fields.length+1+this.params.min);
            var maxValid = this.params.max==undefined || (obj.length <= this.fields.length+1+this.params.max);
            return minValid && maxValid;
        }
        else{
            return obj.length == this.fields.length+1;
        }
    }

    Check(obj){
        if(obj[0] != 'obj'){
            return false;
        }
        if(!this.CheckLength(obj)){
            return false;
        }
        for(var i=0;i<this.fields.length;i++){
            if(!Array.isArray(this.fields[i])){
                if(!this.fields[i].Check(obj[i+1])){
                    return false;
                }
            }
            else{
                if(!this.fields[i][1].Check(obj[i+1])){
                    return false;
                }
            }
        }
        if(this.params){
            for(var i=this.fields.length+1;i<obj.length;i++){
                if(!this.params.element.Check(obj[i])){
                    return false;
                }
            }
        }
        return true;
    }

    Parse(obj){
        var result = {};
        result.type = this.type;
        for(var i=0;i<this.fields.length;i++){
            if(Array.isArray(this.fields[i])){
                var name = this.fields[i][0];
                var parser = this.fields[i][1];
                result[name] = parser.Parse(obj[i+1]);
            }
        }
        if(this.params){
            var name = this.params.name;
            var paramsResult = [];
            for(var i=this.fields.length+1;i<obj.length;i++){
                paramsResult.push(this.params.element.Parse(obj[i]));
            }
            result[name] = paramsResult;
        }
        return result;
    }
}

//copied quite a lot from https://github.com/ColinEberhardt/chasm

// https://webassembly.github.io/spec/core/binary/instructions.html
// https://pengowray.github.io/wasm-ops/
const Opcode = {
    block: 0x02,
    loop: 0x03,
    br: 0x0c,
    br_if: 0x0d,
    if: 0x04,
    else: 0x05,
    end: 0x0b,
    call: 0x10,
    get_local: 0x20,
    set_local: 0x21,
    i32_store_8: 0x3a,
    i32_store: 0x36,
    i32_const: 0x41,
    f32_const: 0x43,
    i32_eqz: 0x45,
    i32_eq: 0x46,
    f32_eq: 0x5b,
    f32_lt: 0x5d,
    f32_gt: 0x5e,
    i32_and: 0x71,
    f32_add: 0x92,
    f32_sub: 0x93,
    f32_mul: 0x94,
    f32_div: 0x95,
    f32_neg: 0x8c,
    i32_trunc_f32_s: 0xa8,
    i32_load: 0x28,
    f32_load: 0x2a,
    f32_store: 0x38,
    i32_mul: 0x6c,
    i32_div: 0x6d,
    i32_add: 0x6a,
    i32_sub: 0x6b,
    i32_lt: 0x48,
    i32_gt: 0x4a,
    f32_convert_i32_s: 0xb2,
    return: 0x0f,
};

// https://webassembly.github.io/spec/core/binary/types.html
const Valtype = {
    i32: 0x7f,
    f32: 0x7d
};

const ieee754 = (n) => {
    var data = new Float32Array([n]);
    var buffer = new ArrayBuffer(data.byteLength);
    var floatView = new Float32Array(buffer).set(data);
    return new Uint8Array(buffer);
};

const encodeString = (str) => [
    str.length,
    ...str.split("").map(s => s.charCodeAt(0))
];

const signedLEB128 = (n) => {
    const buffer = [];
    let more = true;
    const isNegative = n < 0;
    const bitCount = Math.ceil(Math.log2(Math.abs(n))) + 1;
    while (more) {
        let byte = n & 0x7f;
        n >>= 7;
        if (isNegative) {
            n = n | -(1 << (bitCount - 8));
        }
        if ((n === 0 && (byte & 0x40) === 0) || (n === -1 && (byte & 0x40) !== 0x40)) {
            more = false;
        } else {
            byte |= 0x80;
        }
        buffer.push(byte);
    }
    return buffer;
};

const unsignedLEB128 = (n) => {
    const buffer = [];
    do {
        let byte = n & 0x7f;
        n >>>= 7;
        if (n !== 0) {
            byte |= 0x80;
        }
        buffer.push(byte);
    } while (n !== 0);
    return buffer;
};

// https://webassembly.github.io/spec/core/binary/types.html#binary-blocktype
// https://github.com/WebAssembly/design/blob/main/BinaryEncoding.md#value_type
const Blocktype = {
    void: 0x40,
    i32: 0x7f,
}

const flatten = (arr) => [].concat.apply([], arr);

// https://webassembly.github.io/spec/core/binary/modules.html#sections
const Section = {
    custom: 0,
    type: 1,
    import: 2,
    func: 3,
    table: 4,
    memory: 5,
    global: 6,
    export: 7,
    start: 8,
    element: 9,
    code: 10,
    data: 11
};

// http://webassembly.github.io/spec/core/binary/modules.html#export-section
const ExportType = {
    func: 0x00,
    table: 0x01,
    mem: 0x02,
    global: 0x03
}

// http://webassembly.github.io/spec/core/binary/types.html#function-types
const functionType = 0x60;

const emptyArray = 0x0;

// https://webassembly.github.io/spec/core/binary/modules.html#binary-module
const magicModuleHeader = [0x00, 0x61, 0x73, 0x6d];
const moduleVersion = [0x01, 0x00, 0x00, 0x00];

// https://webassembly.github.io/spec/core/binary/conventions.html#binary-vec
// Vectors are encoded with their length followed by their element sequence
const encodeVector = (data) => [
    ...unsignedLEB128(data.length),
    ...flatten(data)
];

// https://webassembly.github.io/spec/core/binary/modules.html#code-section
const encodeLocal = (count, valtype) => [
    ...unsignedLEB128(count),
    valtype
];

// https://webassembly.github.io/spec/core/binary/modules.html#sections
// sections are encoded by their type followed by their vector contents
const createSection = (sectionType, data) => [
    sectionType,
    ...encodeVector(data)
];

const memoryImport = [
    ...encodeString("env"),
    ...encodeString("memory"),
    ExportType.mem,
    /* limits https://webassembly.github.io/spec/core/binary/types.html#limits -
      indicates a min memory size of one page */
    0x00,
    unsignedLEB128(10),
  ];
    var errors = [];

    var expression = new Or();

    var add = new Obj('+', [new Literal('+')], new Params('expressions', expression, 2));

    var call = new Obj('call', [['name', new Varname()]], new Params('args', expression));

    expression.Init([new Varname(), new Int(), new String(), add, call]);

    var _return = new Obj('return', [new Literal('return')], new Params('expressions', expression, 0, 1));

    var assign = new Obj('=', [
        new Literal('='),
        ['name', new Varname()],
        ['expression', expression]]);

    var body = new Or([_return, assign, call]);

    var parameters = new ArrayMultipleOf2(['type', new Varname()], ['name', new Varname()]);

    var int = new Obj('int', [new Literal('int')], new Params('variables', new Varname()));

    var fn = new Obj('fn', [
        ['returnType', new Varname()],
        ['name', new Varname()], 
        ['parameters', parameters],
        ['int', int]
        ], 
        new Params('body', body));

    var exportFn = new Obj('exportFn', [
        new Literal('export'),
        ['returnType', new Varname()],
        ['name', new Varname()], 
        ['parameters', parameters],
        ['int', int]
        ], 
        new Params('body', body));

    var importFn = new Obj('importFn', [
        new Literal('import'),
        ['returnType', new Varname()],
        ['name', new Varname()], 
        ['parameters', parameters],
        ['javascript', new String()]
        ]);

    var base = new Obj('base', [], new Params('values', new Or([importFn, exportFn, fn])));

    var lispTree = LispParser(lispProgram);
    if(!base.Check(lispTree)){
        throw "Cannot begin parse";
    }
    var tree = base.Parse(lispTree);

    if(errors.length>0){
        for(var e of errors){
            console.log(e);
        }
        throw "Parsing errors";
    }

    var importFunctions = tree.values.filter(v=>v.type == 'importFn');
    var nonExportFunctions = tree.values.filter(v=>v.type == 'fn');
    var exportFunctions = tree.values.filter(v=>v.type == 'exportFn');
    var functions = [...nonExportFunctions, ...exportFunctions];
    var allFunctions = [...importFunctions, ...functions];

    for(var i=0;i<allFunctions.length;i++){
        allFunctions[i].id = i;
    }

    function EmitTypeSection(){
        function GetValtype(typeName){
            switch(typeName){
                case 'float': return Valtype.f32;
                case 'int': return Valtype.i32;
                default: throw "Unexpected valtype: "+typeName;
            }
        }
    
        function GetReturnArray(returnType){
            if(returnType == 'void')
                return [];
            else{
                return [GetValtype(returnType)];
            }
        }

        function EmitTypes(functions){
            return functions.map(f=>[
                functionType,
                ...encodeVector(f.parameters.map(p=>GetValtype(p.type))),
                ...encodeVector(GetReturnArray(f.returnType)),
            ]);
        }
        return createSection(Section.type, encodeVector(EmitTypes(allFunctions)));
    }

    function EmitImportSection(){
        function EmitImportFunctions(){
            return importFunctions.map((f,i)=>[
                ...encodeString("env"),
                ...encodeString(f.name),
                ExportType.func,
                ...unsignedLEB128(i)
            ]);
        }

        return createSection(Section.import, encodeVector([...EmitImportFunctions(), memoryImport]));
    }
    
    function EmitFuncSection(){
        return createSection(Section.func, encodeVector(functions.map(f=>f.id)));
    }

    function EmitExportSection(){
       return createSection(
            Section.export,
            encodeVector(exportFunctions.map(f=>[...encodeString(f.name), ExportType.func, ...unsignedLEB128(f.id)])),
        );
    }

    function EmitCodeSection(){
function EmitFunction(allFunctions, f){
    var wasm = [];
    var i32Count = f.int.variables.length;

    var functions = {};
    for(var f of allFunctions){
        functions[f.name] = f;
    }

    var locals = {};
    var id = 0;
    for(var v of f.int.variables){
        locals[v] = {id};
        id++;
    }

    function EmitCall(call){
        for(var a of call.args){
            EmitExpression(a);
        }
        wasm.push(Opcode.call, ...unsignedLEB128(functions[call.name].id));
    }

    function EmitExpression(expression){
        if(expression.type == 'Varname'){
            wasm.push(Opcode.get_local, locals[expression.value].id);
        }
        else if(expression.type == 'Int'){
            wasm.push(Opcode.i32_const, ...signedLEB128(expression.value));
        }
        else if(expression.type == '+'){
            for(var i=0;i<expression.expressions.length;i++){
                EmitExpression(expression.expressions[i]);
                if(i>0){
                    wasm.push(Opcode.i32_add);
                }
            }
        }
        else if(expression.type == 'call'){
            EmitCall(expression);
        }
        else{
            throw "Unexpected expression: "+JSON.stringify(expression);
        }
    }

    function EmitStatement(statement){
        if(statement.type == '='){
            EmitExpression(statement.expression);
            wasm.push(Opcode.set_local, locals[statement.name].id);
        }
        else if(statement.type == 'return'){
            if(statement.expressions.length == 1){
                EmitExpression(statement.expressions[0]);
            }
            wasm.push(Opcode.return);
        }
        else if(statement.type == 'call'){
            EmitCall(statement);
        }
        else{
            throw "Unexpected statement: "+JSON.stringify(statement);
        }
    }

    for(var s of f.body){
        EmitStatement(s);
    }
    return encodeVector([...encodeVector([encodeLocal(i32Count, Valtype.i32)]), ...wasm, Opcode.end])
}
        return createSection(Section.code, encodeVector(functions.map(f=>EmitFunction(allFunctions, f))));
    }

    function ImportObject(){
        var code = "var importObject = {env:{}};\n";
        code+="var global = {};\n";
        for(var f of importFunctions){
            code+="importObject.env."+f.name+"= (";
            for(var i=0;i<f.parameters.length;i++){
                code+=f.parameters[i].name;
                if(i<f.parameters.length-1)
                    code+=',';
            }
            code+=")=>{"
            code+=f.javascript;
            code+="};\n";
        }
        code+="return importObject;\n";
        return new Function('exports', code)(exports);
    }

    const wasm = Uint8Array.from([
        ...magicModuleHeader,
        ...moduleVersion,
        ...EmitTypeSection(),
        ...EmitImportSection(),
        ...EmitFuncSection(),
        ...EmitExportSection(),
        ...EmitCodeSection(),
    ]);

    var exports = {};
    var importObject = ImportObject();
    importObject.env.memory = new WebAssembly.Memory({ initial: 10, maximum: 10 });
    WebAssembly.instantiate(wasm, importObject).then(
        (obj) => {
            for(var f of exportFunctions){
                exports[f.name] = obj.instance.exports[f.name];
            }
            console.log(exports[main]());
        }
    );
}
CompileAndRun("Main");


  </script>
</body>
</html>